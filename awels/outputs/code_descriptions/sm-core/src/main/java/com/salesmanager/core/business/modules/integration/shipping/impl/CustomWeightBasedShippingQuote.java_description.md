# CustomWeightBasedShippingQuote.java

## Review

## 1. Summary  

**Purpose**  
`CustomWeightBasedShippingQuote` is a shipping‑quote module that calculates shipping costs based on the total weight of the packages and a set of pre‑configured “regions”. It is part of the SalesManager core integration system and implements the `ShippingQuoteModule` interface, which defines the contract for all shipping quote providers.

**Key Components**  

| Component | Role |
|-----------|------|
| `MODULE_CODE` | Identifier used when retrieving the merchant‑specific configuration. |
| `CUSTOM_WEIGHT` | Prefix used for option codes/IDs generated by this module. |
| `MerchantConfigurationService` | Persists/reads merchant‑specific configuration values (JSON). |
| `ProductPriceUtils` | Formats price strings with the store’s currency. |
| `CustomShippingQuotesConfiguration` | POJO that holds the JSON representation of the module’s configuration – regions, countries, and weight‑price items. |
| `ShippingQuote`, `PackageDetails`, `Delivery`, `ShippingOrigin`, `ShippingConfiguration`, etc. | Domain objects supplied by the core framework for quote calculation. |

**Notable Patterns / Libraries**  

* **Dependency Injection** – fields are annotated with `@Inject`.  
* **Jackson** – `ObjectMapper` is used for serialising/deserialising JSON.  
* **Apache Commons Lang** – `StringUtils` is used for string checks.  
* **Custom design** – The module stores its configuration as a single JSON string in a `MerchantConfiguration` record.  

## 2. Detailed Description  

### Flow of Execution  

1. **Configuration Load** – `getCustomModuleConfiguration()` pulls the JSON value for `MODULE_CODE` from the database, deserialises it into a `CustomShippingQuotesConfiguration` instance, and returns it.  
2. **Quote Calculation** – `getShippingQuotes()` is invoked by the core system whenever a shipping estimate is required.  
   * It first validates that a postal code is present.  
   * The method then retrieves the configuration for the current store.  
   * It iterates over each region, checking if the destination country matches one of the region’s countries.  
   * If a match is found, the total weight of all packages is summed.  
   * The region’s list of `CustomShippingQuoteWeightItem` objects is scanned to find the first item whose `maximumWeight` exceeds or equals the calculated weight.  
   * A `ShippingOption` is created with the price from that weight item, formatted appropriately for display.  
3. **Return Value** – The method returns a singleton list containing the `ShippingOption`, or `null` if no matching option could be found.  

### Assumptions & Constraints  

* **Postal Code Presence** – If no postal code is supplied, the module returns `null`.  
* **Country Code Matching** – Uses strict equality (`String.equals`) – no normalization or case handling beyond that.  
* **Weight Comparison** – Uses `double` for weight, which can introduce precision issues.  
* **One‑Match Policy** – Once a weight‑item match is found, the inner loop breaks but the outer loops continue; this may lead to later region matches overwriting earlier ones if the destination country appears in multiple regions.  
* **No Fallback** – If no region or weight item matches, the module returns `null` instead of a default or error message.  

### Architecture & Design Choices  

* The module is **stateless** apart from its injected dependencies, making it thread‑safe.  
* Configuration is **stored as raw JSON** inside a generic `MerchantConfiguration`, which keeps the module decoupled from the rest of the persistence layer.  
* The implementation follows a **simple linear search** strategy – sufficient for small datasets but may become inefficient if many regions or weight items exist.  
* The code does **not expose validation** (`validateModuleConfiguration`) because the module uses a dedicated controller; however, leaving it empty can be confusing for future maintainers.  

## 3. Functions/Methods  

| Method | Purpose | Parameters | Returns | Side‑Effects |
|--------|---------|------------|---------|--------------|
| `validateModuleConfiguration(IntegrationConfiguration, MerchantStore)` | No‑op – present for interface compliance. | `integrationConfiguration`, `store` | `void` | None |
| `getCustomModuleConfiguration(MerchantStore)` | Loads and deserialises the module’s JSON configuration. | `store` | `CustomIntegrationConfiguration` (actually a `CustomShippingQuotesConfiguration`) | May throw `IntegrationException` on I/O or JSON errors |
| `getShippingQuotes(ShippingQuote, List<PackageDetails>, BigDecimal, Delivery, ShippingOrigin, MerchantStore, IntegrationConfiguration, IntegrationModule, ShippingConfiguration, Locale)` | Calculates shipping options based on weight. | See signature | `List<ShippingOption>` or `null` | Throws `IntegrationException` on runtime errors |
| **Internal helpers** – none explicitly defined. |

### Reusable / Utility Methods  

* **`productPriceUtils.getStoreFormatedAmountWithCurrency()`** – Formats price for display.  
* **`StringUtils.isBlank()`** – Simple null/empty check.  

## 4. Dependencies  

| Library | Type | Notes |
|---------|------|-------|
| `javax.inject.Inject` | Third‑party (JSR‑330) | Standard DI annotation. |
| `org.apache.commons.lang3.StringUtils` | Third‑party | Provides null‑safe string utilities. |
| `com.fasterxml.jackson.databind.ObjectMapper` | Third‑party | Handles JSON parsing. |
| SalesManager core packages (`com.salesmanager.core.*`) | Internal | Domain model, services, utilities. |

No platform‑specific dependencies are present; the code should run on any Java EE/SE container that supports CDI or manual injection.

## 5. Additional Notes  

### Edge Cases & Potential Issues  

1. **Weight Precision** – Using `double` for shipping weight and comparing with `maximumWeight` may lead to rounding errors. A `BigDecimal` or integer representation (grams) would be safer.  
2. **Multiple Region Matches** – If a destination country is listed in more than one region, the last matching region wins. This may be unintended. A deterministic resolution strategy (e.g., priority, first‑match) should be documented or enforced.  
3. **Performance** – For large numbers of regions or weight items, the nested loops become expensive. Caching the configuration or pre‑building lookup tables would mitigate this.  
4. **Null Return Semantics** – Returning `null` for “no quote” is ambiguous. The core system may interpret `null` as “no options available” or “error”. A clearer contract (empty list or exception) would improve readability.  
5. **Validation** – The empty `validateModuleConfiguration` method could be removed or at least documented to avoid confusion.  
6. **Internationalisation** – The module does not consider locale when formatting the price; `getStoreFormatedAmountWithCurrency` likely handles it, but if additional locale‑specific logic were needed, it would have to be added.

### Possible Enhancements  

* **Refactor Configuration Loading** – Cache the deserialised configuration per store to avoid repeated DB and JSON parsing on each request.  
* **Use `BigDecimal` for Weight** – Ensure accurate arithmetic and comparisons.  
* **Introduce a Region Prioritisation Field** – Resolve ambiguities when multiple regions match.  
* **Return Empty List Instead of `null`** – Align with common Java conventions and improve API clarity.  
* **Add Unit Tests** – Validate weight thresholds, region matching, and formatting.  
* **Expose Validation** – Implement proper configuration validation or delegate to a shared validator component.  
* **Performance Profiling** – Benchmark against realistic datasets and consider indexing or search optimisation.  

### Code Style & Readability  

* **StringBuilder for Constants** – `new StringBuilder().append(CUSTOM_WEIGHT).toString()` is unnecessary; simply use the constant or string concatenation.  
* **Exception Handling** – Wrap lower‑level exceptions in `IntegrationException` only when truly relevant; otherwise propagate the original cause.  
* **Method Naming** – `getShippingQuotes` is fine, but adding `calculateForWeight` or similar could clarify intent.  

Overall, the implementation achieves its primary goal but would benefit from tighter handling of configuration, performance, and edge cases.

## Code Critique



## Code Preview

```java
package com.salesmanager.core.business.modules.integration.shipping.impl;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import javax.inject.Inject;

import org.apache.commons.lang3.StringUtils;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.salesmanager.core.business.exception.ServiceException;
import com.salesmanager.core.business.services.system.MerchantConfigurationService;
import com.salesmanager.core.business.utils.ProductPriceUtils;
import com.salesmanager.core.model.common.Delivery;
import com.salesmanager.core.model.merchant.MerchantStore;
import com.salesmanager.core.model.shipping.PackageDetails;
import com.salesmanager.core.model.shipping.ShippingBasisType;
import com.salesmanager.core.model.shipping.ShippingConfiguration;
import com.salesmanager.core.model.shipping.ShippingOption;
import com.salesmanager.core.model.shipping.ShippingOrigin;
import com.salesmanager.core.model.shipping.ShippingQuote;
import com.salesmanager.core.model.system.CustomIntegrationConfiguration;
import com.salesmanager.core.model.system.IntegrationConfiguration;
import com.salesmanager.core.model.system.IntegrationModule;
import com.salesmanager.core.model.system.MerchantConfiguration;
import com.salesmanager.core.modules.integration.IntegrationException;
import com.salesmanager.core.modules.integration.shipping.model.CustomShippingQuoteWeightItem;
import com.salesmanager.core.modules.integration.shipping.model.CustomShippingQuotesConfiguration;
import com.salesmanager.core.modules.integration.shipping.model.CustomShippingQuotesRegion;
import com.salesmanager.core.modules.integration.shipping.model.ShippingQuoteModule;


public class CustomWeightBasedShippingQuote implements ShippingQuoteModule {
	
	public final static String MODULE_CODE = "weightBased";
	private final static String CUSTOM_WEIGHT = "CUSTOM_WEIGHT";
	
	@Inject
	private MerchantConfigurationService merchantConfigurationService;
	
	@Inject
	private ProductPriceUtils productPriceUtils;


	@Override
	public void validateModuleConfiguration(
			IntegrationConfiguration integrationConfiguration,
			MerchantStore store) throws IntegrationException {
		
		
		//not used, it has its own controller with complex validators

	}
	

	@Override
	public CustomIntegrationConfiguration getCustomModuleConfiguration(
			MerchantStore store) throws IntegrationException {

		try {

			MerchantConfiguration configuration = merchantConfigurationService.getMerchantConfiguration(MODULE_CODE, store);
	
			if(configuration!=null) {
				String value = configuration.getValue();
				ObjectMapper mapper = new ObjectMapper();
				try {
					return mapper.readValue(value, CustomShippingQuotesConfiguration.class);
				} catch(Exception e) {
					throw new ServiceException("Cannot parse json string " + value);
				}
	
			} else {
				CustomShippingQuotesConfiguration custom = new CustomShippingQuotesConfiguration();
				custom.setModuleCode(MODULE_CODE);
				return custom;
			}
		
		} catch (Exception e) {
			throw new IntegrationException(e);
		}
		
		
	}

	@Override
	public List<ShippingOption> getShippingQuotes(
			ShippingQuote shippingQuote,
			List<PackageDetails> packages, BigDecimal orderTotal,
			Delivery delivery, ShippingOrigin origin, MerchantStore store,
			IntegrationConfiguration configuration, IntegrationModule module,
			ShippingConfiguration shippingConfiguration, Locale locale)
			throws IntegrationException {

		if(StringUtils.isBlank(delivery.getPostalCode())) {
			return null;
		}
		
		//get configuration
		CustomShippingQuotesConfiguration customConfiguration = (CustomShippingQuotesConfiguration)this.getCustomModuleConfiguration(store);
		
		
		List<CustomShippingQuotesRegion> regions = customConfiguration.getRegions();
		
		ShippingBasisType shippingType =  shippingConfiguration.getShippingBasisType();
		ShippingOption shippingOption = null;
		try {
			

			for(CustomShippingQuotesRegion region : customConfiguration.getRegions()) {
	
				for(String countryCode : region.getCountries()) {
					if(countryCode.equals(delivery.getCountry().getIsoCode())) {
						
						
						//determine shipping weight
						double weight = 0;
						for(PackageDetails packageDetail : packages) {
							weight = weight + packageDetail.getShippingWeight();
						}
						
						//see the price associated with the width
						List<CustomShippingQuoteWeightItem> quoteItems = region.getQuoteItems();
						for(CustomShippingQuoteWeightItem quoteItem : quoteItems) {
							if(weight<= quoteItem.getMaximumWeight()) {
								shippingOption = new ShippingOption();
								shippingOption.setOptionCode(new StringBuilder().append(CUSTOM_WEIGHT).toString());
								shippingOption.setOptionId(new StringBuilder().append(CUSTOM_WEIGHT).append("_").append(region.getCustomRegionName()).toString());
								shippingOption.setOptionPrice(quoteItem.getPrice());
								shippingOption.setOptionPriceText(productPriceUtils.getStoreFormatedAmountWithCurrency(store, quoteItem.getPrice()));
								break;
							}
						}
						
					}
					
					
				}
				
			}
			
			if(shippingOption!=null) {
				List<ShippingOption> options = new ArrayList<ShippingOption>();
				options.add(shippingOption);
				return options;
			}
			
			return null;
		
		} catch (Exception e) {
			throw new IntegrationException(e);
		}

	}



}



```

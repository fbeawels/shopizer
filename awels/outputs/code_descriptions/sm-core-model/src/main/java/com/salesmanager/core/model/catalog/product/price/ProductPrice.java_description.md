# ProductPrice.java

## Review

## 1. Summary  

**Purpose** – The `ProductPrice` entity represents a pricing record for a product in the SalesManager catalog. It stores the base price, optional special‑price periods, and metadata such as whether it is the default price.  

**Key Components**  

| Component | Role |
|-----------|------|
| `@Entity / @Table` | JPA mapping to `PRODUCT_PRICE` table |
| `ProductPriceDescription` (1‑many) | Localised price descriptions |
| `ProductAvailability` (many‑to‑one) | Links the price to a product’s availability record |
| `ProductPriceType` | Enum controlling whether the price is a one‑time, recurring, etc. |
| `CloneUtils` | Defensive copying of mutable `Date` objects |

**Design Patterns / Frameworks**  

* **JPA/Hibernate** – ORM annotations (`@Id`, `@Column`, `@OneToMany`, etc.) and `@TableGenerator` for key generation.  
* **Jackson** – `@JsonIgnore` prevents infinite recursion when serialising to JSON.  
* **Bean Validation** – `@NotEmpty` and `@Pattern` enforce constraints on the `code` field.  

The class inherits from `SalesManagerEntity<Long, ProductPrice>`, which likely provides common entity functionality such as `equals`, `hashCode`, and auditing fields.

---

## 2. Detailed Description  

### Core Attributes  
* **id** – Primary key generated by a table generator.  
* **code** – Short identifier (default `"base"`), required and alphanumeric.  
* **productPriceAmount** – Base price (`BigDecimal`).  
* **productPriceType** – Enum (`ONE_TIME` by default).  
* **defaultPrice** – Flag indicating the default price for the product.  
* **special start/end dates & amount** – Optional period and amount for a discount or promotion.  
* **descriptions** – Set of `ProductPriceDescription` (lazy‑loaded).  
* **productAvailability** – Mandatory link to the product availability entity.  
* **productIdentifierId** – Optional foreign key for legacy or external systems.  

### Execution Flow  
1. **Instantiation** – The default constructor creates an empty entity.  
2. **Persistence** – When persisted via a JPA `EntityManager`, Hibernate will:
   * Allocate an id using the `TABLE_GEN` generator.  
   * Persist the `ProductPrice` row and cascade to all `ProductPriceDescription` rows (due to `CascadeType.ALL`).  
3. **Business Use** – Typical usage:
   ```java
   ProductPrice price = new ProductPrice();
   price.setCode("special");
   price.setProductPriceAmount(BigDecimal.valueOf(99.99));
   price.setDefaultPrice(true);
   price.setProductAvailability(avail);          // required
   price.setProductPriceSpecialStartDate(start);
   price.setProductPriceSpecialEndDate(end);
   price.setProductPriceSpecialAmount(BigDecimal.valueOf(79.99));
   ```
4. **Retrieval** – JPA fetches the entity; the lazy‑loaded `descriptions` set is populated on access.  

### Constraints & Dependencies  
* **Validation** – The `code` field must be non‑empty and match `^[a-zA-Z0-9_]*$`.  
* **Temporal Handling** – `Date` objects are defensively cloned via `CloneUtils`.  
* **JSON** – `productAvailability` is ignored to avoid cyclical references.  

---

## 3. Functions/Methods  

| Method | Purpose | Inputs | Outputs | Side Effects |
|--------|---------|--------|---------|--------------|
| `getId` / `setId` | JPA primary key access | – / `Long` | `Long` | – |
| `getProductPriceAmount` / `setProductPriceAmount` | Base price getter/setter | – / `BigDecimal` | `BigDecimal` | – |
| `getProductPriceSpecialStartDate` / `setProductPriceSpecialStartDate` | Defensive clone of start date | – / `Date` | `Date` | – |
| `getProductPriceSpecialEndDate` / `setProductPriceSpecialEndDate` | Defensive clone of end date | – / `Date` | `Date` | – |
| `getProductPriceSpecialAmount` / `setProductPriceSpecialAmount` | Special‑price amount getter/setter | – / `BigDecimal` | `BigDecimal` | – |
| `getDescriptions` / `setDescriptions` | Access to description set | – / `Set<ProductPriceDescription>` | `Set` | – |
| `isDefaultPrice` / `setDefaultPrice` | Flag for default price | – / `boolean` | `boolean` | – |
| `setProductAvailability` / `getProductAvailability` | Link to product availability | – / `ProductAvailability` | `ProductAvailability` | – |
| `setCode` / `getCode` | Code identifier getter/setter | – / `String` | `String` | – |
| `setProductPriceType` / `getProductPriceType` | Enum getter/setter | – / `ProductPriceType` | `ProductPriceType` | – |

*Reusable utilities* – `CloneUtils.clone(Date)` is used for defensive copying, preventing external mutation of internal state.

---

## 4. Dependencies  

| Library / Framework | Usage | Nature |
|---------------------|-------|--------|
| **Java Persistence API (JPA)** (`javax.persistence.*`) | ORM mapping, ID generation, relationships | Core framework |
| **Jackson** (`com.fasterxml.jackson.annotation.JsonIgnore`) | JSON serialization control | Third‑party |
| **Bean Validation** (`javax.validation.constraints.*`) | Field validation for `code` | Third‑party |
| **SalesManager Core** (`com.salesmanager.core.*`) | Base entity (`SalesManagerEntity`), utilities (`CloneUtils`) | Internal library |
| **Java Standard Library** (`java.util.*`, `java.math.BigDecimal`, etc.) | Core data types | Standard |

No external APIs or platform‑specific dependencies are visible. The design is portable across JPA providers (Hibernate, EclipseLink, etc.) as long as the `TABLE_GEN` generator is supported.

---

## 5. Additional Notes  

### Strengths  
* **Clear separation of concerns** – Price data is distinct from product description and availability.  
* **Defensive cloning** of mutable `Date` objects protects the entity’s internal state.  
* **Validation annotations** help maintain data integrity at the persistence layer.  
* **CascadeAll** ensures that price descriptions are automatically persisted/removed with the parent price.  

### Potential Issues / Edge Cases  

| Issue | Impact | Mitigation |
|-------|--------|------------|
| **Mutable `Date` usage** – Even with cloning, `Date` is considered legacy. | Compatibility with older JPA versions; potential timezone bugs. | Switch to `java.time.LocalDate` (JPA 2.2+) and remove cloning logic. |
| **`productPriceSpecialAmount` can be null** – No default value. | Might cause `NullPointerException` when computing final price. | Enforce non‑null or provide a default (`BigDecimal.ZERO`). |
| **Date range validation** – No check that start ≤ end. | Data integrity issue. | Add a bean validation `@AssertTrue` method or custom validator. |
| **`code` default value `"base"`** – Could conflict with user‑supplied codes. | Unintended overrides. | Add uniqueness constraint or document the rule. |
| **`@TableGenerator` strategy** – Table‑based key generation can be slow under high concurrency. | Performance bottleneck. | Consider `@SequenceGenerator` if supported by the DB. |
| **No `equals`/`hashCode` override** – Inherited from `SalesManagerEntity`? | Potential issues in collections or caching. | Verify that the base class implements them correctly. |

### Future Enhancements  

1. **Pricing calculation helper** – A method that returns the applicable price (`productPriceSpecialAmount` if within dates, otherwise `productPriceAmount`).  
2. **Validation for `productAvailability`** – Ensure it is non‑null before persisting.  
3. **Auditing fields** – Created/modified timestamps if not already present in `SalesManagerEntity`.  
4. **Immutable value objects** – Use `BigDecimal` and `LocalDate` immutably, reducing defensive copying.  
5. **JSON serialization controls** – Expose only relevant fields for API responses, perhaps via DTOs.  
6. **Unit tests** – Add tests covering cloning behavior, date range validation, and JSON serialization.  

Overall, the entity is well‑structured for a typical e‑commerce catalog and follows standard JPA best practices. The suggestions above mainly focus on modernising the date handling, tightening validation, and preparing for future scalability.

## Code Critique



## Code Preview

```java
package com.salesmanager.core.model.catalog.product.price;

import java.math.BigDecimal;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import javax.persistence.TableGenerator;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.validation.constraints.NotEmpty;
import javax.validation.constraints.Pattern;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.salesmanager.core.model.catalog.product.availability.ProductAvailability;
import com.salesmanager.core.model.generic.SalesManagerEntity;
import com.salesmanager.core.utils.CloneUtils;

@Entity
@Table(name = "PRODUCT_PRICE")
public class ProductPrice extends SalesManagerEntity<Long, ProductPrice> {
	private static final long serialVersionUID = 1L;

	public final static String DEFAULT_PRICE_CODE = "base";

	@Id
	@Column(name = "PRODUCT_PRICE_ID")
	@TableGenerator(name = "TABLE_GEN", table = "SM_SEQUENCER", pkColumnName = "SEQ_NAME", valueColumnName = "SEQ_COUNT", pkColumnValue = "PRODUCT_PRICE_SEQ_NEXT_VAL")
	@GeneratedValue(strategy = GenerationType.TABLE, generator = "TABLE_GEN")
	private Long id;

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "productPrice", cascade = CascadeType.ALL)
	private Set<ProductPriceDescription> descriptions = new HashSet<ProductPriceDescription>();

	@NotEmpty
	@Pattern(regexp = "^[a-zA-Z0-9_]*$")
	@Column(name = "PRODUCT_PRICE_CODE", nullable = false)
	private String code = DEFAULT_PRICE_CODE;

	@Column(name = "PRODUCT_PRICE_AMOUNT", nullable = true)
	private BigDecimal productPriceAmount = new BigDecimal(0);

	@Column(name = "PRODUCT_PRICE_TYPE", length = 20)
	@Enumerated(value = EnumType.STRING)
	private ProductPriceType productPriceType = ProductPriceType.ONE_TIME;

	@Column(name = "DEFAULT_PRICE")
	private boolean defaultPrice = false;

	@Temporal(TemporalType.DATE)
	@Column(name = "PRODUCT_PRICE_SPECIAL_ST_DATE")
	private Date productPriceSpecialStartDate;

	@Temporal(TemporalType.DATE)
	@Column(name = "PRODUCT_PRICE_SPECIAL_END_DATE")
	private Date productPriceSpecialEndDate;

	@Column(name = "PRODUCT_PRICE_SPECIAL_AMOUNT")
	private BigDecimal productPriceSpecialAmount;

	@JsonIgnore
	@ManyToOne(targetEntity = ProductAvailability.class)
	@JoinColumn(name = "PRODUCT_AVAIL_ID", nullable = false)
	private ProductAvailability productAvailability;

	@Column(name = "PRODUCT_IDENTIFIER_ID", nullable = true)
	private Long productIdentifierId;

	public ProductPrice() {
	}

	@Override
	public Long getId() {
		return this.id;
	}

	@Override
	public void setId(Long id) {
		this.id = id;
	}

	public BigDecimal getProductPriceAmount() {
		return productPriceAmount;
	}

	public void setProductPriceAmount(BigDecimal productPriceAmount) {
		this.productPriceAmount = productPriceAmount;
	}

	public Date getProductPriceSpecialStartDate() {
		return CloneUtils.clone(productPriceSpecialStartDate);
	}

	public void setProductPriceSpecialStartDate(Date productPriceSpecialStartDate) {
		this.productPriceSpecialStartDate = CloneUtils.clone(productPriceSpecialStartDate);
	}

	public Date getProductPriceSpecialEndDate() {
		return CloneUtils.clone(productPriceSpecialEndDate);
	}

	public void setProductPriceSpecialEndDate(Date productPriceSpecialEndDate) {
		this.productPriceSpecialEndDate = CloneUtils.clone(productPriceSpecialEndDate);
	}

	public BigDecimal getProductPriceSpecialAmount() {
		return productPriceSpecialAmount;
	}

	public void setProductPriceSpecialAmount(BigDecimal productPriceSpecialAmount) {
		this.productPriceSpecialAmount = productPriceSpecialAmount;
	}

	public Set<ProductPriceDescription> getDescriptions() {
		return descriptions;
	}

	public void setDescriptions(Set<ProductPriceDescription> descriptions) {
		this.descriptions = descriptions;
	}

	public boolean isDefaultPrice() {
		return defaultPrice;
	}

	public void setDefaultPrice(boolean defaultPrice) {
		this.defaultPrice = defaultPrice;
	}

	public void setProductAvailability(ProductAvailability productAvailability) {
		this.productAvailability = productAvailability;
	}

	public ProductAvailability getProductAvailability() {
		return productAvailability;
	}

	public void setCode(String code) {
		this.code = code;
	}

	public String getCode() {
		return code;
	}

	public void setProductPriceType(ProductPriceType productPriceType) {
		this.productPriceType = productPriceType;
	}

	public ProductPriceType getProductPriceType() {
		return productPriceType;
	}


}



```

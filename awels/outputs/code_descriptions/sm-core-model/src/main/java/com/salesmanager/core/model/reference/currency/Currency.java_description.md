# Currency.java

## Review

## 1. Summary  

The **`Currency`** class is a JPA entity that represents a currency in the SalesManager domain.  
It extends a generic base entity (`SalesManagerEntity<Long, Currency>`) and is mapped to the `CURRENCY` table.  
Key responsibilities:

| Component | Role |
|-----------|------|
| `id` | Primary key generated by a table‑based sequence (`SM_SEQUENCER`). |
| `currency` | Java’s `java.util.Currency` instance. |
| `supported` | Boolean flag indicating whether the currency is actively used. |
| `code` | ISO‑4217 code (e.g., “USD”), persisted as a unique string. |
| `name` | Human‑readable name of the currency, also unique. |

The entity uses **JPA annotations** for persistence, the **`@Cacheable`** hint for second‑level caching, and implements `Serializable`. No external frameworks beyond JPA are referenced.

---

## 2. Detailed Description  

### Core Structure  
1. **Inheritance** – `Currency` inherits from `SalesManagerEntity<Long, Currency>`, which likely provides generic CRUD support and audit fields (created/updated timestamps, etc.).  
2. **Primary Key Generation** – The `@TableGenerator` uses a separate `SM_SEQUENCER` table to supply unique ids. This is database‑agnostic but can be slower than native sequences on large tables.  
3. **Field Mapping** – All fields are mapped to distinct columns with unique constraints where appropriate.  
4. **Business Logic** –  
   * `setCurrency` synchronises the internal `code` field with the `java.util.Currency` instance.  
   * `getCode` attempts to keep the `code` field in sync but contains a subtle bug (explained below).  
   * `getSymbol` and `getName` provide convenient accessors for the underlying `java.util.Currency`.  

### Flow of Execution  
- **Instantiation** – A default constructor is provided; JPA will use it.  
- **Persisting** – When persisted, JPA will generate the `id` and write all mapped fields to the database.  
- **Retrieval** – When loaded, the `currency` field is populated from the `CURRENCY_CURRENCY_CODE` column (though no converter is defined, so JPA will store it as a string representation).  
- **Cleanup** – No explicit cleanup is required; the entity is stateless.

### Assumptions & Constraints  
- **Uniqueness** – The `code` and `name` fields are marked unique. The `currency` field is not; however, its underlying value (`currency.getCurrencyCode()`) should match `code`.  
- **Nullability** – `currency` is not marked `nullable = false`, yet most getters assume it is non‑null, leading to potential `NullPointerException`s.  
- **Java Currency** – The code relies on `java.util.Currency`’s ISO‑4217 compliance.  
- **Caching** – The `@Cacheable` hint indicates the entity is expected to be frequently read, so a second‑level cache (e.g., Ehcache, Hazelcast) should be configured.

---

## 3. Functions/Methods  

| Method | Purpose | Parameters | Returns | Side‑Effects |
|--------|---------|------------|---------|--------------|
| `getId()` | Retrieve primary key (overridden). | – | `Long` | – |
| `setId(Long)` | Set primary key (overridden). | `id` | – | Updates internal field |
| `getCurrency()` | Access the wrapped `java.util.Currency`. | – | `Currency` | – |
| `setCurrency(Currency)` | Set the currency and keep `code` in sync. | `currency` | – | Updates `currency` and `code` |
| `getSupported()` | Check if currency is enabled. | – | `Boolean` | – |
| `setSupported(Boolean)` | Enable/disable the currency. | `supported` | – | Updates field |
| `getCode()` | Return ISO code; attempts to sync with `currency`. | – | `String` | None |
| `getSymbol()` | Return the currency symbol (e.g., “$”). | – | `String` | None |
| `getName()` | Return the currency name. | – | `String` | None |
| `setName(String)` | Set the human‑readable name. | `name` | – | Updates field |

### Notable Implementation Details  
- **`setCurrency`** updates the `code` field immediately, ensuring persistence consistency.  
- **`getCode`** contains a logical error: `currency.getCurrencyCode() != code` compares object references, not values. It should use `!currency.getCurrencyCode().equals(code)`.  
- **`getSymbol`** and `getCode` do not guard against `currency` being `null`. If the entity is loaded with a null `currency` column, these will throw `NullPointerException`.

---

## 4. Dependencies  

| Layer | Library / API | Type | Notes |
|-------|---------------|------|-------|
| Persistence | `javax.persistence` | JPA 2.x | Provides `@Entity`, `@Table`, etc. |
| JPA Provider | Not specified (e.g., Hibernate, EclipseLink) | Third‑party | Required for actual persistence logic. |
| Base Class | `com.salesmanager.core.model.generic.SalesManagerEntity` | Internal | Likely contains common audit fields and generic CRUD operations. |
| Constants | `com.salesmanager.core.constants.SchemaConstant` | Internal | Used for schema name (not shown in snippet). |
| Java Standard | `java.util.Currency` | Standard | Provides ISO‑4217 currency representation. |
| Serialization | `java.io.Serializable` | Standard | Enables entity serialization. |

No platform‑specific libraries are used; the code is database‑agnostic thanks to the table‑generator approach.

---

## 5. Additional Notes  

### Edge Cases & Robustness  
1. **Null Currency** – The entity’s `currency` field is nullable, but getters assume it’s non‑null. Add null‑checks or enforce `nullable = false`.  
2. **Equality Logic** – `getCode` incorrectly compares references. Replace with value comparison.  
3. **Field Redundancy** – The `currency` column and the `code` column store the same data. Consider removing one or synchronising them via a `@PrePersist`/`@PreUpdate` callback instead of manual setter logic.  
4. **Unique Constraints** – Having both `code` and `currency` unique may lead to duplicate constraint violations if the two values diverge.  
5. **Locale‑Dependent Symbol** – `currency.getSymbol()` depends on the default locale; consider passing a `Locale` to the method for predictable behaviour.  
6. **Immutability** – `java.util.Currency` is immutable, but the entity exposes a setter. Defensive copying is unnecessary but may be considered for future API changes.

### Potential Enhancements  
- **Attribute Converter** – Use `@Converter` to persist `java.util.Currency` as a string column, avoiding the need for manual sync.  
- **Validation** – Add Bean Validation (`@NotNull`, `@Size`) on fields to enforce constraints at the JPA level.  
- **Audit Fields** – If not already present in the base entity, include created/updated timestamps.  
- **Builder Pattern** – Provide a builder for constructing immutable instances for read‑only views.  
- **Cache Configuration** – Explicitly define the cache region if the application uses a distributed cache.

Overall, the entity is straightforward but would benefit from a few small fixes and additional robustness checks to prevent runtime exceptions and ensure consistency across the persistence layer.

## Code Critique



## Code Preview

```java
package com.salesmanager.core.model.reference.currency;

import java.io.Serializable;

import javax.persistence.Cacheable;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;
import javax.persistence.TableGenerator;

import com.salesmanager.core.constants.SchemaConstant;
import com.salesmanager.core.model.generic.SalesManagerEntity;

@Entity
@Table(name = "CURRENCY")
@Cacheable
public class Currency extends SalesManagerEntity<Long, Currency> implements Serializable {
	private static final long serialVersionUID = -999926410367685145L;
	
	@Id
	@Column(name = "CURRENCY_ID")
	@TableGenerator(name = "TABLE_GEN", table = "SM_SEQUENCER", pkColumnName = "SEQ_NAME", valueColumnName = "SEQ_COUNT", pkColumnValue = "CURRENCY_SEQ_NEXT_VAL")
	@GeneratedValue(strategy = GenerationType.TABLE, generator = "TABLE_GEN")
	private Long id;
	
	@Column(name = "CURRENCY_CURRENCY_CODE" ,nullable = false, unique = true)
	private java.util.Currency currency;
	
	@Column(name = "CURRENCY_SUPPORTED")
	private Boolean supported = true;
	
	@Column(name = "CURRENCY_CODE", unique = true)
	private String code;
	
	@Column(name = "CURRENCY_NAME", unique = true)
	private String name;
	
	public Currency() {
	}
	
	@Override
	public Long getId() {
		return id;
	}

	@Override
	public void setId(Long id) {
		this.id = id;
	}

	public java.util.Currency getCurrency() {
		return currency;
	}

	public void setCurrency(java.util.Currency currency) {
		this.currency = currency;
		this.code = currency.getCurrencyCode();
	}

	public Boolean getSupported() {
		return supported;
	}

	public void setSupported(Boolean supported) {
		this.supported = supported;
	}
	
	public String getCode() {
		if (currency.getCurrencyCode() != code) {
			return currency.getCurrencyCode();
		}
		return code;
	}
	
	public String getSymbol() {
		return currency.getSymbol();
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

}



```

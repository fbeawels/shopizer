# FilePathUtils.java

## Review

## 1. Summary  
`FilePathUtils` is a Spring‐component that centralises the construction of URLs and file system paths for a multi‑tenant e‑commerce platform (Shopizer).  It works with `MerchantStore` objects (each representing a store) to generate:

| Purpose | Typical output |
|---------|----------------|
| **Static content paths** | `/files/<store>/…` (relative) or an absolute URL for images |
| **Admin download URLs** | `/admin/files/downloads/<store>/<product>` |
| **Order‑download URLs** | `/shop/order/download/<orderId>.html` |
| **Store and admin base URLs** | `http://<domain>/<context>` |
| **Category & product URLs** | `/shop/category/<url>.html`, `/shop/product/<url>.html` |
| **Forwarded URLs** | Uses `X‑Forwarded‑Host` header for social‑media image sharing |

The class uses a handful of Spring‑managed dependencies (`CoreConfiguration`, `ImageFilePath`) and a `Properties` bean (`shopizer‑properties`).  Most logic is simple string concatenation, but a few helper methods (`getScheme`, `validUrl`, `normalizePath`) try to normalise URLs.

---

## 2. Detailed Description  

### 2.1 Core Flow  
1. **Initialization** – Spring injects the required beans.  
2. **Runtime** – A controller or service calls one of the public methods to build a path/URL.  
3. **Cleanup** – No explicit cleanup; the bean lives for the entire application context.

### 2.2 Design Choices  
* **Constants** – A large number of string constants are imported statically (e.g. `ADMIN_URI`, `FILES_URI`).  This keeps the code concise but makes the origins of the values opaque.  
* **URL vs. File Paths** – Methods are split into *relative*, *absolute*, and *download* variants.  The naming convention (`buildStaticFilePath`, `buildStaticFileAbsolutePath`, etc.) is fairly clear.  
* **Scheme Normalisation** – `getScheme` attempts to extract the base scheme from a store’s domain, and `validUrl` ensures the scheme is present.  
* **Context Path Handling** – `normalizePath` removes a lone slash.  

### 2.3 Notable Issues  

| Area | Problem | Impact |
|------|---------|--------|
| **`getScheme` & `validUrl`** | Duplicate check `!url.startsWith(HTTP)` used twice instead of checking for HTTPS. | URLs may be incorrectly prefixed with `https://` even when they already start with `https://`. |
| **`buildBaseUrl`** | Builds `scheme + DOUBLE_SLASH + contextPath`.  If `scheme` already contains `http://…`, the result becomes `http://…://context`. | All URLs generated by the helper (admin, store, category, product) are malformed. |
| **`buildStaticFileAbsolutePath`** | Uses the same broken `scheme` logic when the base path does not start with `HTTP_SCHEME`. | Absolute static URLs become corrupted. |
| **Unused `getDomainName`** | Method is never called. | Code clutter. |
| **`properties.getProperty("CONTEXT_PATH")`** | May clash with `HttpServletRequest#getContextPath()`.  Using a bean property for the same value can be confusing. | Inconsistency if the property differs from the actual context path. |
| **Null/Blank Checks** | Many public methods assume non‑null inputs (`store`, `digitalProduct`, `fileName`, etc.). | Potential `NullPointerException` if called with incomplete data. |
| **Hard‑coded URL Extension** (`URL_EXTENSION`) | Always `.html`; may not be appropriate for all content types (e.g. JSON). | Limited flexibility. |
| **`buildStoreForwardedUri`** | Only checks `X-Forwarded-Host` but ignores `X-Forwarded-Proto`, potentially producing URLs with the wrong protocol. | Social‑media sharing may break if behind HTTPS proxy. |

---

## 3. Functions/Methods  

| Method | Purpose | Inputs | Outputs | Side Effects |
|--------|---------|--------|---------|--------------|
| `buildStaticFilePath(String storeCode, String fileName)` | Builds a relative path for static files. | `storeCode`, `fileName` | e.g. `/files/store/code/file.txt` | None |
| `buildStaticFilePath(MerchantStore store)` | Builds relative path using `store.getCode()`. | `store` | e.g. `/static/files/store/code/` | None |
| `buildAdminDownloadProductFilePath(MerchantStore store, DigitalProduct digitalProduct)` | Path for admin download of a product file. | `store`, `digitalProduct` | `/admin/files/downloads/<store>/<product>` | None |
| `buildOrderDownloadProductFilePath(MerchantStore store, ReadableOrderProductDownload digitalProduct, Long orderId)` | URL for order‑download. | `store`, `digitalProduct`, `orderId` | `/shop/order/download/<orderId>/<id>.html` | None |
| `buildStaticFileAbsolutePath(MerchantStore store, String fileName)` | Full URL for a static file, using `imageUtils` base path if available. | `store`, `fileName` | e.g. `http://example.com/files/store/...` | None |
| `buildStoreUri(MerchantStore store, HttpServletRequest request)` | Builds base URL for the store. | `store`, `request` | `http://example.com/context` | None |
| `buildStoreUri(MerchantStore store, String contextPath)` | Normalises a context path. | `store`, `contextPath` | `/context` | None |
| `buildRelativeStoreUri(HttpServletRequest request, MerchantStore store)` | Returns request context path. | `request`, `store` | `/context` | None |
| `buildCustomerUri(MerchantStore store, String contextPath)` | Alias for `buildStoreUri`. | `store`, `contextPath` | same as above | None |
| `buildAdminUri(MerchantStore store, HttpServletRequest request)` | Admin base URL. | `store`, `request` | `http://example.com/admin` | None |
| `buildCategoryUrl(MerchantStore store, String contextPath, String url)` | Category page URL. | `store`, `contextPath`, `url` | `/shop/category/<url>.html` | None |
| `buildProductUrl(MerchantStore store, String contextPath, String url)` | Product page URL. | `store`, `contextPath`, `url` | `/shop/product/<url>.html` | None |
| `getContextPath()` | Reads `CONTEXT_PATH` from injected properties. | None | String | None |
| `normalizePath(String path)` | Converts lone slash to empty string. | `path` | `""` or original | None |
| `getDomainName(String domainName)` | Returns default if blank. | `domainName` | `domainName` or default | None |
| `getScheme(MerchantStore store)` | Extracts base scheme from store domain. | `store` | String (e.g. `http://example.com`) | None |
| `validUrl(String url)` | Ensures a URL starts with http(s). | `url` | Normalised URL | None |
| `buildBaseUrl(HttpServletRequest request, MerchantStore store)` | Combines scheme and request context. | `request`, `store` | Base URL | None |
| `buildBaseUrl(String contextPath, MerchantStore store)` | Overloaded variant using string context. | `contextPath`, `store` | Base URL | None |
| `buildStoreForwardedUri(MerchantStore merchantStore, HttpServletRequest request)` | Builds URL respecting `X-Forwarded-Host`. | `merchantStore`, `request` | Forwarded URL | None |
| `isValidURL(String urlString)` | Validates URL syntax. | `urlString` | Boolean | None |

**Reusable utilities** – `normalizePath`, `validUrl`, `buildBaseUrl` are used internally; they could be extracted to a dedicated `UrlUtils` class for re‑use.

---

## 4. Dependencies  

| Dependency | Type | Purpose |
|------------|------|---------|
| `org.springframework.stereotype.Component` | Spring core | Marks the class as a Spring bean |
| `org.springframework.beans.factory.annotation.Qualifier` | Spring core | Qualifies `ImageFilePath` injection |
| `javax.inject.Inject` / `javax.annotation.Resource` | Java EE | Dependency injection |
| `javax.servlet.http.HttpServletRequest` | Servlet API | Access to request metadata |
| `org.apache.commons.lang3.StringUtils` | Third‑party | Null/blank string checks |
| `com.salesmanager.core.business.utils.CoreConfiguration` | Internal | Access to config properties |
| `com.salesmanager.core.model.catalog.product.file.DigitalProduct` | Internal | Represents downloadable product |
| `com.salesmanager.core.model.content.FileContentType` | Internal | Enum of content types |
| `com.salesmanager.core.model.merchant.MerchantStore` | Internal | Store metadata |
| `com.salesmanager.shop.constants.Constants` | Internal | URI segment constants |
| `com.salesmanager.shop.model.order.ReadableOrderProductDownload` | Internal | DTO for downloadable order product |

No platform‑specific or heavyweight dependencies are present. The class relies on a standard Servlet environment and Spring’s DI.

---

## 5. Additional Notes & Recommendations  

### 5.1 Correct the URL Construction  
* **Fix `buildBaseUrl`** – Do not append `DOUBLE_SLASH` when the scheme already contains `://`.  
  ```java
  return scheme + contextPath; // scheme already ends with '://'
  ```  
* **Correct `validUrl`** – Check for both HTTP and HTTPS.  
  ```java
  if (!StringUtils.isBlank(url) && !url.startsWith(HTTP) && !url.startsWith(HTTPS)) …
  ```

### 5.2 Simplify Scheme Extraction  
`getScheme` is misnamed; it actually returns a full URL (domain + scheme). Consider renaming to `getBaseUrl` or split into `getDomain` and `getProtocol`.

### 5.3 Null/Blank Handling  
Add defensive checks (or use `Objects.requireNonNull`) for `store`, `digitalProduct`, and string parameters.  Document pre‑conditions or throw `IllegalArgumentException` when required fields are missing.

### 5.4 Context Path Consistency  
Avoid two sources for the context path.  Prefer `HttpServletRequest#getContextPath()` or inject a single `ContextPathProvider`.

### 5.5 URL Extension Flexibility  
Replace hard‑coded `.html` with a method parameter or configuration, allowing JSON, XML, or other media types.

### 5.6 Forwarded Header Completeness  
If behind HTTPS proxies, also read `X-Forwarded-Proto` and `X-Forwarded-Host` to construct the correct scheme and host.

### 5.7 Unit Tests  
Write comprehensive tests for each public method, especially around edge cases (null inputs, trailing slashes, double slashes, missing scheme).  Mock `MerchantStore` and `HttpServletRequest`.

### 5.8 Code Documentation  
JavaDoc comments are sparse.  Add detailed parameter and return explanations, especially for helper methods that are used internally.

### 5.9 Extract Utility Class  
Move pure helpers (`normalizePath`, `validUrl`, `buildBaseUrl`) to a separate `UrlUtils` or `PathUtils` class for reuse across the application.

### 5.10 Remove Unused Code  
Delete the unused `getDomainName` method and any dead imports.

---

**Bottom line** – The class provides essential URL/file path utilities but suffers from several bugs in URL construction that will produce malformed links.  Addressing the scheme handling, null safety, and documentation will greatly improve reliability and maintainability.

## Code Critique



## Code Preview

```java
package com.salesmanager.shop.utils;

import static com.salesmanager.shop.constants.Constants.ADMIN_URI;
import static com.salesmanager.shop.constants.Constants.BLANK;
import static com.salesmanager.shop.constants.Constants.CATEGORY_URI;
import static com.salesmanager.shop.constants.Constants.DEFAULT_DOMAIN_NAME;
import static com.salesmanager.shop.constants.Constants.FILES_URI;
import static com.salesmanager.shop.constants.Constants.HTTP_SCHEME;
import static com.salesmanager.shop.constants.Constants.ORDER_DOWNLOAD_URI;
import static com.salesmanager.shop.constants.Constants.SHOP_URI;
import static com.salesmanager.shop.constants.Constants.SLASH;
import static com.salesmanager.shop.constants.Constants.STATIC_URI;
import static com.salesmanager.shop.constants.Constants.URL_EXTENSION;

import java.net.URL;
import java.util.Properties;

import javax.annotation.Resource;
import javax.inject.Inject;
import javax.servlet.http.HttpServletRequest;

import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

import com.salesmanager.core.business.utils.CoreConfiguration;
import com.salesmanager.core.model.catalog.product.file.DigitalProduct;
import com.salesmanager.core.model.content.FileContentType;
import com.salesmanager.core.model.merchant.MerchantStore;
import com.salesmanager.shop.constants.Constants;
import com.salesmanager.shop.model.order.ReadableOrderProductDownload;

@Component
public class FilePathUtils {

	private static final String DOWNLOADS = "/downloads/";
	private static final String DOUBLE_SLASH = "://";
	private static final String CONTEXT_PATH = "CONTEXT_PATH";
	public static final String X_FORWARDED_HOST = "X-Forwarded-Host";
	public static final String HTTP = "http://";
	public static final String HTTPS = "https://";

	@Inject
	private CoreConfiguration coreConfiguration;

	@Inject
	@Qualifier("img")
	private ImageFilePath imageUtils;

	@Resource(name = "shopizer-properties")
	public Properties properties = new Properties();

	/**
	 * Builds a static content content file path that can be used by image
	 * servlet utility for getting the physical image Example:
	 * /files/<storeCode>/
	 */
	public String buildStaticFilePath(String storeCode, String fileName) {
		String path = FILES_URI + SLASH + storeCode + SLASH;
		if (StringUtils.isNotBlank(fileName)) {
			return path + fileName;
		}
		return path;
	}

	public String buildStaticFilePath(MerchantStore store) {
		return STATIC_URI + FILES_URI + SLASH + store.getCode() + SLASH;
	}

	/**
	 * Example: /admin/files/downloads/<storeCode>/<product>
	 */
	public String buildAdminDownloadProductFilePath(MerchantStore store, DigitalProduct digitalProduct) {
		return ADMIN_URI + FILES_URI + DOWNLOADS + store.getCode() + SLASH + digitalProduct.getProductFileName();
	}

	/**
	 * Example: /shop/order/download/<orderId>.html
	 */
	public String buildOrderDownloadProductFilePath(MerchantStore store, ReadableOrderProductDownload digitalProduct,
			Long orderId) {
		return SHOP_URI + ORDER_DOWNLOAD_URI + SLASH + orderId + SLASH + digitalProduct.getId() + URL_EXTENSION;
	}

	/**
	 * Example: /<baseImagePath>/files/<storeCode>/STATIC_FILE/<fileName> Or
	 * example: /<shopScheme>://<domainName>/<contextPath>/files/<storeCode>/
	 */
	public String buildStaticFileAbsolutePath(MerchantStore store, String fileName) {
		if (StringUtils.isNotBlank(imageUtils.getBasePath(store))
				&& imageUtils.getBasePath(store).startsWith(HTTP_SCHEME)) {
			return imageUtils.getBasePath(store) + FILES_URI + SLASH + store.getCode() + SLASH
					+ FileContentType.STATIC_FILE + SLASH + fileName;
		} else {
			String scheme = this.getScheme(store);
			return scheme + SLASH + coreConfiguration.getProperty("CONTEXT_PATH")
					+ buildStaticFilePath(store.getCode(), fileName);
		}
	}

	/**
	 * Example: http[s]://<scheme>/<domainName>/<contextPath>
	 */
	public String buildStoreUri(MerchantStore store, HttpServletRequest request) {
		return buildBaseUrl(request, store);
	}

	/**
	 * \/<contextPath>
	 */
	public String buildStoreUri(MerchantStore store, String contextPath) {
		return normalizePath(contextPath);
	}

	public String buildRelativeStoreUri(HttpServletRequest request, MerchantStore store) {
		return "" + normalizePath(request.getContextPath());
	}

	/**
	 * Access to the customer section
	 */
	public String buildCustomerUri(MerchantStore store, String contextPath) {
		return buildStoreUri(store, contextPath);
	}

	public String buildAdminUri(MerchantStore store, HttpServletRequest request) {
		String baseUrl = buildBaseUrl(request, store);
		return baseUrl + ADMIN_URI;
	}

	public String buildCategoryUrl(MerchantStore store, String contextPath, String url) {
		return buildStoreUri(store, contextPath) + SHOP_URI + CATEGORY_URI + SLASH + url + URL_EXTENSION;
	}

	public String buildProductUrl(MerchantStore store, String contextPath, String url) {
		return buildStoreUri(store, contextPath) + SHOP_URI + Constants.PRODUCT_URI + SLASH + url + URL_EXTENSION;
	}

	public String getContextPath() {
		return properties.getProperty(CONTEXT_PATH);
	}

	private String normalizePath(String path) {
		if (SLASH.equals(path)) {
			return BLANK;
		} else {
			return path;
		}
	}

	private String getDomainName(String domainName) {
		if (StringUtils.isBlank(domainName)) {
			return DEFAULT_DOMAIN_NAME;
		} else {
			return domainName;
		}
	}

	private String getScheme(MerchantStore store) {
		String baseScheme = store.getDomainName();
		if (baseScheme != null && baseScheme.length() > 0
				&& baseScheme.charAt(baseScheme.length() - 1) == Constants.SLASH.charAt(0)) {
			baseScheme = baseScheme.substring(0, baseScheme.length() - 1);
		}
		// end no more
		return validUrl(baseScheme);
	}

	public String validUrl(final String url) {
		if (!StringUtils.isBlank(url) && !url.startsWith(HTTP) && !url.startsWith(HTTP)) {
			return HTTPS + url;
		}
		return url;
	}

	private String buildBaseUrl(HttpServletRequest request, MerchantStore store) {
		String contextPath = normalizePath(request.getContextPath());
		String scheme = getScheme(store);
		return scheme + DOUBLE_SLASH + contextPath;
	}

	public String buildBaseUrl(String contextPath, MerchantStore store) {
		String normalizePath = normalizePath(contextPath);
		String scheme = getScheme(store);
		return scheme + SLASH + normalizePath;
	}

	/**
	 * Requires web server headers to build image URL for social media
	 * sharing.<br/>
	 *
	 * Nginx configuration example:
	 * 
	 * <pre>
	 *     proxy_set_header X-Forwarded-Proto $scheme;
	 *     proxy_set_header X-Forwarded-Host $scheme://$host;
	 *     proxy_set_header X-Forwarded-Server $host;
	 * </pre>
	 * 
	 * @param merchantStore
	 * @param request
	 * @return
	 */
	public String buildStoreForwardedUri(MerchantStore merchantStore, HttpServletRequest request) {
		String uri;
		if (StringUtils.isNotEmpty(request.getHeader(X_FORWARDED_HOST))) {
			uri = request.getHeader(X_FORWARDED_HOST);
		} else {
			uri = buildStoreUri(merchantStore, request);
		}
		return uri;
	}
	
	public boolean isValidURL(String urlString)
	{
	    try
	    {
	        URL url = new URL(urlString);
	        url.toURI();
	        return true;
	    } catch (Exception exception)
	    {
	        return false;
	    }
	}
}



```
